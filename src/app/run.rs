use super::build::PolarBearApp;
use crate::proot::setup::launch;
use crate::utils::config;
use crate::utils::logging::PolarBearExpectation;
use crate::wayland::compositor::State;
use crate::wayland::compositor::{send_frames_surface_tree, ClientState};
use crate::wayland::input::{
    RelativePosition, WinitInput, WinitKeyboardInputEvent, WinitMouseInputEvent,
    WinitMouseMovedEvent, WinitMouseWheelEvent, WinitTouchCancelledEvent, WinitTouchEndedEvent,
    WinitTouchMovedEvent, WinitTouchStartedEvent,
};
use crate::wayland::keymap::physicalkey_to_scancode;
use crate::wayland::winit_backend::bind;
use smithay::backend::input::{AbsolutePositionEvent, InputEvent, KeyboardKeyEvent, TouchEvent};
use smithay::backend::renderer::element::surface::{
    render_elements_from_surface_tree, WaylandSurfaceRenderElement,
};
use smithay::backend::renderer::element::Kind;
use smithay::backend::renderer::gles::GlesRenderer;
use smithay::backend::renderer::utils::draw_render_elements;
use smithay::backend::renderer::{Color32F, Frame, Renderer};
use smithay::input::keyboard::FilterResult;
use smithay::input::touch::{DownEvent, MotionEvent, UpEvent};
use smithay::output::{Mode, Output, PhysicalProperties, Scale, Subpixel};
use smithay::utils::{Physical, Rectangle, Size, Transform, SERIAL_COUNTER};
use std::sync::Arc;
use std::thread;
use winit::application::ApplicationHandler;
use winit::event::{ElementState, Touch, TouchPhase, WindowEvent};
use winit::event_loop::ActiveEventLoop;
use winit::window::WindowId;

/// Specific events generated by Winit
#[derive(Debug)]
pub enum CentralizedEvent {
    /// The window has been resized
    Resized {
        /// The new physical size (in pixels)
        size: Size<i32, Physical>,
        /// The new scale factor
        scale_factor: f64,
    },

    /// The focus state of the window changed
    Focus(bool),

    /// An input event occurred.
    Input(InputEvent<WinitInput>),

    /// The user requested to close the window.
    CloseRequested,

    /// A redraw was requested
    Redraw,

    /// TODO: Support these events
    Unsupported,
}

impl PolarBearApp {
    fn timestamp(&self) -> u64 {
        self.data.clock.now().as_millis() as u64
    }
}

impl ApplicationHandler for PolarBearApp {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        let backend = bind(&event_loop);
        let window_size = backend.window_size();
        let scale_factor = backend.scale_factor();
        let size = (window_size.w, window_size.h);
        self.backend.graphic_renderer = Some(backend);
        self.backend.compositor.state.size = size.into();

        // Create the Output with given name and physical properties.
        let output = Output::new(
            "Polar Bear Wayland Compositor".into(), // the name of this output,
            PhysicalProperties {
                size: size.into(),                 // dimensions (width, height) in mm
                subpixel: Subpixel::HorizontalRgb, // subpixel information
                make: "Polar Bear".into(),         // make of the monitor
                model: config::VERSION.into(),     // model of the monitor
            },
        );

        let dh = self.backend.compositor.display.handle();
        // create a global, if you want to advertise it to clients
        let _global = output.create_global::<State>(
            &dh, // the display
        ); // you can drop the global, if you never intend to destroy it.
           // Now you can configure it
        output.change_current_state(
            Some(Mode {
                size: size.into(),
                refresh: 60000,
            }), // the resolution mode,
            Some(Transform::Normal), // global screen transformation
            Some(Scale::Fractional(scale_factor)), // global screen scaling factor
            Some((0, 0).into()),     // output position
        );
        // set the preferred mode
        output.set_preferred(Mode {
            size: size.into(),
            refresh: 60000,
        });

        thread::spawn(move || {
            let launch_command = "dbus-launch startxfce4".to_string();
            launch(launch_command);
        });
    }

    fn window_event(&mut self, event_loop: &ActiveEventLoop, id: WindowId, event: WindowEvent) {
        // Map raw events to our own events
        let event = match event {
            WindowEvent::Resized(size) => {
                let (w, h): (i32, i32) = size.into();

                CentralizedEvent::Resized {
                    size: (w, h).into(),
                    scale_factor: self.data.scale_factor,
                }
            }
            WindowEvent::ScaleFactorChanged {
                scale_factor: new_scale_factor,
                ..
            } => {
                self.data.scale_factor = new_scale_factor;
                let (w, h): (i32, i32) = self
                    .backend
                    .graphic_renderer
                    .as_ref()
                    .unwrap()
                    .window()
                    .inner_size()
                    .into();
                CentralizedEvent::Resized {
                    size: (w, h).into(),
                    scale_factor: self.data.scale_factor,
                }
            }
            WindowEvent::RedrawRequested => CentralizedEvent::Redraw,
            WindowEvent::CloseRequested => CentralizedEvent::CloseRequested,
            WindowEvent::Focused(focused) => CentralizedEvent::Focus(focused),
            WindowEvent::KeyboardInput {
                event,
                is_synthetic,
                ..
            } if !is_synthetic && !event.repeat => {
                match event.state {
                    ElementState::Pressed => self.data.key_counter += 1,
                    ElementState::Released => {
                        self.data.key_counter = self.data.key_counter.saturating_sub(1);
                    }
                };

                let scancode = physicalkey_to_scancode(event.physical_key).unwrap_or(0);
                let event = InputEvent::Keyboard {
                    event: WinitKeyboardInputEvent {
                        time: self.timestamp(),
                        key: scancode,
                        count: self.data.key_counter,
                        state: event.state,
                    },
                };
                CentralizedEvent::Input(event)
            }
            WindowEvent::CursorMoved { position, .. } => {
                let size = self
                    .backend
                    .graphic_renderer
                    .as_ref()
                    .unwrap()
                    .window()
                    .inner_size();
                let x = position.x / size.width as f64;
                let y = position.y / size.height as f64;
                let event = InputEvent::PointerMotionAbsolute {
                    event: WinitMouseMovedEvent {
                        time: self.timestamp(),
                        position: RelativePosition::new(x, y),
                        global_position: position,
                    },
                };
                CentralizedEvent::Input(event)
            }
            WindowEvent::MouseWheel { delta, .. } => {
                let event = InputEvent::PointerAxis {
                    event: WinitMouseWheelEvent {
                        time: self.timestamp(),
                        delta,
                    },
                };
                CentralizedEvent::Input(event)
            }
            WindowEvent::MouseInput { state, button, .. } => {
                let event = InputEvent::PointerButton {
                    event: WinitMouseInputEvent {
                        time: self.timestamp(),
                        button,
                        state,
                        is_x11: false,
                    },
                };
                CentralizedEvent::Input(event)
            }
            WindowEvent::Touch(winit::event::Touch {
                phase: TouchPhase::Started,
                location,
                id,
                ..
            }) => {
                let size = self
                    .backend
                    .graphic_renderer
                    .as_ref()
                    .unwrap()
                    .window()
                    .inner_size();
                let x = location.x / size.width as f64;
                let y = location.y / size.width as f64;
                let event = InputEvent::TouchDown {
                    event: WinitTouchStartedEvent {
                        time: self.timestamp(),
                        global_position: location,
                        position: RelativePosition::new(x, y),
                        id,
                    },
                };

                CentralizedEvent::Input(event)
            }
            WindowEvent::Touch(Touch {
                phase: TouchPhase::Moved,
                location,
                id,
                ..
            }) => {
                let size = self
                    .backend
                    .graphic_renderer
                    .as_ref()
                    .unwrap()
                    .window()
                    .inner_size();
                let x = location.x / size.width as f64;
                let y = location.y / size.width as f64;
                let event = InputEvent::TouchMotion {
                    event: WinitTouchMovedEvent {
                        time: self.timestamp(),
                        position: RelativePosition::new(x, y),
                        global_position: location,
                        id,
                    },
                };

                CentralizedEvent::Input(event)
            }

            WindowEvent::Touch(Touch {
                phase: TouchPhase::Ended,
                location,
                id,
                ..
            }) => {
                let size = self
                    .backend
                    .graphic_renderer
                    .as_ref()
                    .unwrap()
                    .window()
                    .inner_size();
                let x = location.x / size.width as f64;
                let y = location.y / size.width as f64;
                let event = InputEvent::TouchMotion {
                    event: WinitTouchMovedEvent {
                        time: self.timestamp(),
                        position: RelativePosition::new(x, y),
                        global_position: location,
                        id,
                    },
                };
                (CentralizedEvent::Input(event));

                let event = InputEvent::TouchUp {
                    event: WinitTouchEndedEvent {
                        time: self.timestamp(),
                        id,
                    },
                };

                CentralizedEvent::Input(event)
            }

            WindowEvent::Touch(Touch {
                phase: TouchPhase::Cancelled,
                id,
                ..
            }) => {
                let event = InputEvent::TouchCancel {
                    event: WinitTouchCancelledEvent {
                        time: self.timestamp(),
                        id,
                    },
                };
                CentralizedEvent::Input(event)
            }
            _ => {
                println!("Unhandled event: {:?}", event);
                CentralizedEvent::Unsupported
            }
        };

        // Handle the centralized events
        match event {
            CentralizedEvent::CloseRequested => {
                println!("The close button was pressed; stopping");
                event_loop.exit();
            }
            CentralizedEvent::Redraw => {
                if let Some(backend) = self.backend.graphic_renderer.as_mut() {
                    let size = backend.window_size();
                    let damage = Rectangle::from_size(size);
                    {
                        let (renderer, mut framebuffer) = backend.bind().unwrap();

                        let compositor = &mut self.backend.compositor;

                        let elements = compositor
                            .state
                            .xdg_shell_state
                            .toplevel_surfaces()
                            .iter()
                            .flat_map(|surface| {
                                render_elements_from_surface_tree(
                                    renderer,
                                    surface.wl_surface(),
                                    (0, 0),
                                    1.0,
                                    1.0,
                                    Kind::Unspecified,
                                )
                            })
                            .collect::<Vec<WaylandSurfaceRenderElement<GlesRenderer>>>();

                        let mut frame = renderer
                            .render(&mut framebuffer, size, Transform::Flipped180)
                            .unwrap();
                        frame
                            .clear(Color32F::new(0.1, 0.0, 0.0, 1.0), &[damage])
                            .unwrap();
                        draw_render_elements(&mut frame, 1.0, &elements, &[damage]).unwrap();
                        // We rely on the nested compositor to do the sync for us
                        let _ = frame.finish().unwrap();

                        for surface in compositor.state.xdg_shell_state.toplevel_surfaces() {
                            send_frames_surface_tree(
                                surface.wl_surface(),
                                compositor.start_time.elapsed().as_millis() as u32,
                            );
                        }

                        if let Some(stream) = compositor
                            .listener
                            .accept()
                            .pb_expect("Failed to accept listener")
                        {
                            println!("Got a client: {:?}", stream);

                            let client = compositor
                                .display
                                .handle()
                                .insert_client(stream, Arc::new(ClientState::default()))
                                .unwrap();
                            compositor.clients.push(client);
                        }

                        compositor
                            .display
                            .dispatch_clients(&mut compositor.state)
                            .pb_expect("Failed to dispatch clients");
                        compositor
                            .display
                            .flush_clients()
                            .pb_expect("Failed to flush clients");
                    }

                    // It is important that all events on the display have been dispatched and flushed to clients before
                    // swapping buffers because this operation may block.
                    backend.submit(Some(&[damage])).unwrap();
                }

                // Redraw the application.
                //
                // It's preferable for applications that do not render continuously to render in
                // this event rather than in AboutToWait, since rendering in here allows
                // the program to gracefully handle redraws requested by the OS.

                // Draw.

                // Queue a RedrawRequested event.
                //
                // You only need to call this if you've determined that you need to redraw in
                // applications which do not always need to. Applications that redraw continuously
                // can render here instead.
                self.backend
                    .graphic_renderer
                    .as_ref()
                    .unwrap()
                    .window()
                    .request_redraw();
            }
            CentralizedEvent::Input(event) => match event {
                InputEvent::Keyboard { event } => {
                    let compositor = &mut self.backend;
                    let state = &mut compositor.compositor.state;
                    let serial = SERIAL_COUNTER.next_serial();
                    let time = compositor.compositor.start_time.elapsed().as_millis() as u32;
                    compositor.compositor.keyboard.input::<(), _>(
                        state,
                        event.key_code(),
                        event.state(),
                        serial,
                        time,
                        |_, _, _| {
                            //
                            FilterResult::Forward
                        },
                    );
                }
                InputEvent::TouchDown { event } => {
                    let compositor = &mut self.backend;
                    let state = &mut compositor.compositor.state;
                    if let Some(surface) = state
                        .xdg_shell_state
                        .toplevel_surfaces()
                        .iter()
                        .next()
                        .cloned()
                    {
                        compositor.compositor.keyboard.set_focus(
                            state,
                            Some(surface.wl_surface().clone()),
                            0.into(),
                        );
                        let serial = SERIAL_COUNTER.next_serial();
                        let time = compositor.compositor.start_time.elapsed().as_millis() as u32;
                        compositor.compositor.touch.down(
                            state,
                            Some((surface.wl_surface().clone(), (0f64, 0f64).into())),
                            &DownEvent {
                                slot: event.slot(),
                                location: (event.x(), event.y()).into(),
                                serial,
                                time,
                            },
                        );
                    };
                }
                InputEvent::TouchUp { event } => {
                    let compositor = &mut self.backend;
                    let state = &mut compositor.compositor.state;
                    if let Some(surface) = state
                        .xdg_shell_state
                        .toplevel_surfaces()
                        .iter()
                        .next()
                        .cloned()
                    {
                        let serial = SERIAL_COUNTER.next_serial();
                        let time = compositor.compositor.start_time.elapsed().as_millis() as u32;
                        compositor.compositor.touch.up(
                            state,
                            &UpEvent {
                                slot: event.slot(),
                                serial,
                                time,
                            },
                        );
                    };
                }
                InputEvent::TouchMotion { event } => {
                    let compositor = &mut self.backend;
                    let state = &mut compositor.compositor.state;
                    if let Some(surface) = state
                        .xdg_shell_state
                        .toplevel_surfaces()
                        .iter()
                        .next()
                        .cloned()
                    {
                        let time = compositor.compositor.start_time.elapsed().as_millis() as u32;
                        compositor.compositor.touch.motion(
                            state,
                            Some((surface.wl_surface().clone(), (0f64, 0f64).into())),
                            &MotionEvent {
                                slot: event.slot(),
                                location: (event.x(), event.y()).into(),
                                time,
                            },
                        );
                    };
                }
                _ => {}
            },
            _ => (),
        }
    }
}
